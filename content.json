{"pages":[],"posts":[{"title":"네이버 부스트캠프 AI Tech 3주차 주간학습정리 Data Viz - Bar Plot","text":"2022년 2월 3일(목)부터 4일(금)까지 네이버 부스트캠프(boostcamp) AI Tech강의를 들으면서 중요하다고 생각되거나 짚고 넘어가야 할 핵심 내용들만 간단하게 메모한 내용입니다. 틀리거나 설명이 부족한 내용이 있을 수 있으며, 이는 학습을 진행하면서 꾸준히 내용을 수정하거나 추가해나갈 예정입니다. Bar PlotBar PlotBar Plot이란?직사각형 막대를 사용하여 데이터의 값을 표현하는 차트이자 그래프이다. 막대 그래프, bar chart, bar graph 등의 이름으로도 사용된다. 범주(category)에 따른 수치 값을 비교하기에 적절한 방법이며, 개별 비교, 그룹 비교 모두 적합하다. 막대의 방향에 따른 분류 수직 (vetrical) .bar() $x$축에 범주, $y$축에 값을 표기 (default) 수평 (horizontal) .barh() $y$축에 범주, $x$축에 값을 표기 범주가 많을 때 적절하다. 다양한 Bar PlotMultiple Bar PlotBar Plot에서는 범주에 대해 각 값을 표현해서 1개의 feature에 대해서만 보여준다. 여러 Group(Feature)을 보여주기 위해서는 다음과 같은 방법이 있다. 플롯을 여러 개 그리는 방법 한 개의 플롯에 동시에 나타내는 방법 (Good) 쌓아서 표현하는 방법 겹쳐서 표현하는 방법 이웃에 배치하여 표현하는 방법 Stacked Bar Plot두 개 이상의 그룹을 쌓아서 표현하는 bar plot이며, 각 bar에서 나타나는 그룹의 순서는 항상 유지한다. 맨 밑의 bar 분포 또는 전체 총합에 대한 분포를 파악하기는 쉽지만 그 외의 분포들을 관찰이 어렵다는 단점이 있다.이는 수치에 대한 주석을 직접 달아주는 방법으로 보완할 수 있다. 2개의 그룹이 서로 positive와 negative인 반대의 의미를 지니면 축을 조정할 수 있다. .bar()에서는 bottom 파라미터를 사용한다. .barh()에서는 left 파라미터를 사용한다. Percentage Stacked Bar Chart각각의 범주에 대해서 전체에 대한 비율을 표시하는 bar chart이다. Overlapped Bar Plot두 개 그룹만 비교한다면 겹쳐서 만드는 것도 선택지가 될 수 있다.단, 3개 이상의 그룹일 때는 파악이 어려운 단점이 있다.이때는 bar plot보다는 area plot이 더 효율적이다. 같은 축을 사용해서 비교가 쉬워진다. alpha로 투명도를 조정하며, 실제 색상의 명도나 채도도 함께 고려해야 한다. Grouped Bar Plot그룹별 범주에 따른 bar를 이웃되게 배치하는 방법이며, 여러 group을 비교할 때 가장 추천되는 방법이다. Matplotlib는 범주형보다는 수치형 데이터에 더 적합해서 다른 bar plot보다는 구현이 상대적으로 까다롭다. Group이 5개~7개일 때 효과적이며, 그룹이 이보다 더 많으면 비율이 적은 그룹은 ETC로 처리할 수 있다. Bar Plot 사용 시 유의점지켜야 할 원칙: Principle of Portion Ink 실제 값과 그에 표현되는 그래픽으로 표현되는 잉크 양은 비례해야 한다!. 반드시 $x$축의 시작은 Zero(0)이어야 한다. 막대 그래프에만 한정되는 원칙이 아니라 Area Plot, Donut Chart 등 다수의 시각화에서도 적용된다. 데이터 정렬하기더 정확한 정보를 전달하려면 정렬이 필수적이다.Pandas에서는 sort_values(), sort_index()를 사용하여 정렬한다. 데이터의 종류에 따라 정렬하는 기준을 다르게 해야 한다. 시계열: 시간순 수치형: 크기순 순서형: 범주의 순서대로 명목형: 범주의 값에 따라 정렬 한 가지 정렬이 정답이 아니므로 여러 가지 기준으로 정렬하여 패턴을 발견할 수 있어야 한다. 대시보드에서는 사용자의 요청에 따라 interactive하게 제공하는 것이 유용하다. 적절한 공간 활용여백과 공간만 조정해도 가독성이 높아진다. Matplotlib의 bar plot은 ax에 꽉 차게 그려져서 답답한 느낌을 줄 수 있다. 이를 해결하는 테크닉으로 다음과 같은 것들이 존재한다. X/Y axis Limit .set_xlim(), .set_ylim() Spines .spines[spine].set_visible() Gap width Legend .legend() 범례의 위치를 어디에 두는가도 중요하다. Margins .margins() 양옆의 테두리를 조정할 수 있다. 복잡함과 단순함필요없는 복잡함으로 화려하게 디자인할 필요가 없다.무의미한 3D의 사용뿐만이 아니라 직사각형이 아닌 다른 형태의 bar 사용도 지양해야 한다. 무엇을 보고 싶은지, 시각화를 보는 대상이 누구인지를 고려해야 한다. 정확한 차이(EDA)를 보여줘야 하는 경우 Grid(.grid()) 격자로 데이터가 정확히 어떤 값인지 보조적으로 알려줄 수 있다. Ticklabels(.set_ticklabels())를 사용하여 필요한 값을 명시할 수 있다. 큰 틀에서 비교 및 추세 파악(Dashboard)을 위한 경우 Grid를 빼고 필요한 정보를 최소화하는 게 중요하다. 오차 막대를 추가하여 Uncertainty 정보를 추가할 수 있다. (errorbar) Bar 사이의 Gap을 0으로 하려면 히스토그램(Histogram)을 사용한다..hist()를 사용하여 구현이 가능하며, 연속된 느낌을 줄 수 있다는 특징이 있다. 제목(.set_title()), 라벨(.set_xlabel(), .set_ylabel()) 등 다양한 text 정보를 활용할 수 있다. Bar Plot 사용 예시.bar()와 .barh()123456789fig, axes = plt.subplots(1, 2, figsize=(12, 7))x = list('ABCDE')y = np.array([1, 2, 3, 4, 5])axes[0].bar(x, y)axes[1].barh(x, y)plt.show() .sample().sample()은 데이터를 랜덤으로 추출하므로 전체 데이터의 분포를 파악하는 용도로서 .head()보다는 .sample()을 사용하는 것이 더 유용하다. 12student = pd.read_csv('./StudentsPerformance.csv')student.sample(5) .info()각 column마다 데이터의 null값이 얼마나 있는지, 데이터 타입은 무엇인지를 파악할 수 있다. 1student.info() .describe()미리 데이터의 통계 정보를 살펴볼 수 있다. 1student.describe(include='all') Multiple Bar Plotmatplotlib는 자동으로 여백의 크기를 맞춰줘서 수치의 스케일이 다를 수 있다. 1234fig, axes = plt.subplots(1, 2, figsize=(15, 7))axes[0].bar(group['male'].index, group['male'], color='royalblue')axes[1].bar(group['female'].index, group['female'], color='tomato')plt.show() 이를 해결하는 두 가지 방법 서브플롯을 만들 때 sharey 파라미터를 사용하는 방법 1fig, axes = plt.subplots(1, 2, figsize=(15, 7), sharey=True) y축 범위를 개별적으로 조정하는 방법 12for ax in axes: ax.set_ylim(0, 200) Stacked Bar Plot여러 그룹을 순서대로 쌓아서 그룹에 대한 전체 비율을 알기 쉽다.bottom 파라미터를 사용해서 아래 공간을 비워둘 수 있다. 1234567891011fig, axes = plt.subplots(1, 2, figsize=(15, 7))group_cnt = student['race/ethnicity'].value_counts().sort_index()axes[0].bar(group_cnt.index, group_cnt, color='darkgray')axes[1].bar(group['male'].index, group['male'], color='royalblue')axes[1].bar(group['female'].index, group['female'], bottom=group['male'], color='tomato')for ax in axes: ax.set_ylim(0, 350) plt.show() Percentage Stacked Bar Plotgroup을 역순 정렬하지 않고 쌓으면 위에서 아래로 정렬되는 그룹 순서가 반대가 되므로 미리 정렬할 때 역순 정렬을 한다. 12345678910111213141516171819fig, ax = plt.subplots(1, 1, figsize=(12, 7))group = group.sort_index(ascending=False) # 역순 정렬total = group['male'] + group['female'] # 각 그룹별 합ax.barh(group['male'].index, group['male']/total, color='royalblue')ax.barh(group['female'].index, group['female']/total, left=group['male']/total, color='tomato')ax.set_xlim(0, 1)# 네 면의 모서리를 모두 안 보이게 한다.for s in ['top', 'bottom', 'left', 'right']: ax.spines[s].set_visible(False)plt.show() Overlapped Bar Plot1234567891011121314151617181920group = group.sort_index() # 다시 정렬fig, axes = plt.subplots(2, 2, figsize=(12, 12))axes = axes.flatten()# 투명도에 따라 bar plot이 어떻게 그려지는지 확인한다.for idx, alpha in enumerate([1, 0.7, 0.5, 0.3]): axes[idx].bar(group['male'].index, group['male'], color='royalblue', alpha=alpha) axes[idx].bar(group['female'].index, group['female'], color='tomato', alpha=alpha) axes[idx].set_title(f'Alpha = {alpha}') for ax in axes: ax.set_ylim(0, 200) plt.show() Grouped Bar Plot $x$축 조정 $x$축에서 약간 벗어나게 하려면 $x$값 자체를 조정해 줘야 한다. width 조정 xticks, xticklabels 123456789101112131415161718fig, ax = plt.subplots(1, 1, figsize=(12, 7))# 각 group의 이름을 서수로 얻을 수 있어야 한다.idx = np.arange(len(group['male'].index))width=0.35ax.bar(idx-width/2, group['male'], color='royalblue', width=width)ax.bar(idx+width/2, group['female'], color='tomato', width=width)ax.set_xticks(idx)ax.set_xticklabels(group['male'].index) plt.show() label과 legend를 통해 비교가 편한 범례를 추가할 수도 있다. 123456789101112131415161718fig, ax = plt.subplots(1, 1, figsize=(12, 7))idx = np.arange(len(group['male'].index))width=0.35ax.bar(idx-width/2, group['male'], color='royalblue', width=width, label='Male')ax.bar(idx+width/2, group['female'], color='tomato', width=width, label='Female')ax.set_xticks(idx)ax.set_xticklabels(group['male'].index)ax.legend() plt.show() index $i$(zero-index)에 대해서는 다음과 같이 x좌표를 계산할 수 있다. $x + \\frac{−𝑁 + 1 + 2 × 𝑖}{2} × 𝑤𝑖𝑑𝑡ℎ$ 123456789101112131415161718group = student.groupby('parental level of education')['race/ethnicity'].value_counts().sort_index()group_list = sorted(student['race/ethnicity'].unique())edu_lv = student['parental level of education'].unique()fig, ax = plt.subplots(1, 1, figsize=(13, 7))x = np.arange(len(group_list))width = 0.12for idx, g in enumerate(edu_lv): ax.bar(x+(-len(edu_lv)+1+2*idx)*width/2, group[g], width=width, label=g)ax.set_xticks(x)ax.set_xticklabels(group_list)ax.legend() plt.show() seaborn에서는 countplot을 통해 직접 $x$축의 위치를 지정할 필요 없이 좀 더 편하게 Grouped Bar plot 구현이 가능하다. 가독성 높게 바꾸기123456789101112131415161718192021group_cnt = student['race/ethnicity'].value_counts().sort_index()fig = plt.figure(figsize=(15, 7))ax_basic = fig.add_subplot(1, 2, 1)ax = fig.add_subplot(1, 2, 2)ax_basic.bar(group_cnt.index, group_cnt)ax.bar(group_cnt.index, group_cnt, width=0.7, edgecolor='black', linewidth=2, color='royalblue' )ax.margins(0.1, 0.1)for s in ['top', 'right']: ax.spines[s].set_visible(False)plt.show() Grid와 Text 추가하기가독성과 정확성을 고려하여 Grid 또는 실제 수치에 대한 Text를 추가할 수 있다. 123456789101112131415161718192021222324252627group_cnt = student['race/ethnicity'].value_counts().sort_index()fig, axes = plt.subplots(1, 2, figsize=(15, 7))for ax in axes: ax.bar(group_cnt.index, group_cnt, width=0.7, edgecolor='black', linewidth=2, color='royalblue', zorder=10 ) ax.margins(0.1, 0.1) for s in ['top', 'right']: ax.spines[s].set_visible(False)axes[1].grid(zorder=0)for idx, value in zip(group_cnt.index, group_cnt): axes[1].text(idx, value+5, s=value, ha='center', fontweight='bold' ) plt.show() 오차막대(errorbar) 추가하기yerr 파라미터를 전달하여 오차막대를 추가할 수 있다. capsize로 위아래의 수직선의 크기를 조정할 수 있다. 123456789101112131415161718192021222324252627282930313233343536score_var = student.groupby('gender').std().Tfig, ax = plt.subplots(1, 1, figsize=(10, 10))idx = np.arange(len(score.index))width=0.3ax.bar(idx-width/2, score['male'], color='royalblue', width=width, label='Male', yerr=score_var['male'], capsize=10 )ax.bar(idx+width/2, score['female'], color='tomato', width=width, label='Female', yerr=score_var['female'], capsize=10 )ax.set_xticks(idx)ax.set_xticklabels(score.index)ax.set_ylim(0, 100)ax.spines['top'].set_visible(False)ax.spines['right'].set_visible(False)ax.legend()ax.set_title('Gender / Score', fontsize=20)ax.set_xlabel('Subject', fontweight='bold')ax.set_ylabel('Score', fontweight='bold')plt.show()","link":"/2022/02/06/20220206-Data-Viz-Bar-Plot/"},{"title":"네이버 부스트캠프 AI Tech 1주차 주간학습정리 AI Math - 벡터(Vector)","text":"2022년 1월 17일(월)부터 21일(금)까지 네이버 부스트캠프(boostcamp) AI Tech강의를 들으면서 중요하다고 생각되거나 짚고 넘어가야 할 핵심 내용들만 간단하게 메모한 내용입니다. 틀리거나 설명이 부족한 내용이 있을 수 있으며, 이는 학습을 진행하면서 꾸준히 내용을 수정하거나 추가해나갈 예정입니다. 벡터(Vector)벡터는 다음과 같이 다양하게 정의할 수 있다. 크기(길이)와 방향을 가지는 직선 벡터 공간(Vector Space)을 이루는 원소 공간에서의 한 점 원점으로부터의 상대적 위치 수를 원소로 가지는 리스트 또는 배열 종합하면 벡터는 수를 원소로 가지는 list 또는 array를 의미하며, $n$차원 공간에서의 한 점을 의미한다.이 때 점은 원점으로부터의 상대적 위치를 의미한다. numpy에서는 통상 행벡터로 값을 처리한다.Vector의 element는 $[x_1, x_2, …, x_d]$로 표현된다. 벡터는 표현 방식에 따라 두 가지로 분류할 수 있다. 행벡터(횡벡터): 벡터의 원소를 가로로 나열하여 표현 열벡터(종벡터): 벡터의 원소를 세로로 나열하여 표현 벡터의 연산(Vector Operation)벡터의 덧셈과 뺄셈같은 차원을 지닌 둘 이상의 벡터에서 서로 대응하는 성분끼리 덧셈 또는 뺄셈이 가능하다.즉, Shape이 같은 Vector간에는 동일한 위치의 element간의 연산이 일어난다.다른 벡터로부터의 상대적인 이동으로 나타낼 수도 있다.또한 더하는 벡터의 방향을 반대로 하면 뺄셈으로 연산할 수 있다. 벡터의 곱셈벡터의 모든 성분에 같은 수를 곱하는 것이다. 벡터에 수를 곱하면 벡터의 길이가 변한다.즉, 벡터(Vector)와 스칼라(Scalar) 연산을 하면 원점으로부터의 이동에 길이 변화가 생긴다. NLP에서 벡터를 어떻게 사용할까?언어를 처리하기 위해 단어를 벡터로 취급할 수도 있다.벡터 연산처럼 단어도 덧셈과 뺄셈 연산을 가능하도록 한다.예) ‘수도’ + ‘미국’ = ‘워싱턴 D.C.’ Norm원점으로부터의 거리를 의미하며, $|x|$로 표현된다.Norm의 정의에 따라 기하학적 성질 또는 표현이 달라진다. L1 Norm$||\\mathbf{x}||_1 = \\sum_{i=1}^{d}{|x_i|}$ 각 성분의 변화량의 절댓값을 모두 더한다. 맨해튼 거리와 같다. Robust 학습, Lasso 회귀 L2 Norm$ ||\\mathbf{x}||_2 = \\sqrt{\\sum_{i=1}^{d}{x_{i}^2}} $ 피타고라스 정리로 유클리드 거리를 계산한다. 시작점에서 끝점까지 직선으로 움직인 거리를 의미한다. Laplace 근사, Ridge 회귀 정규화항을 더하여 계수의 절댓값이나 제곱한 값이 커지지 않도록 만들어줄 때 유용하다. 두 Vector의 관계벡터 사이의 거리L1, L2 Norm을 이용하여 백터의 뺄셈을 사용해 두 벡터 사이의 거리를 계산할 수 있다.두 Vector x와 y의 거리는 $ZeroVector$와 $x−y$의 거리와 동일하다. $|x - y| = |y - x|$ 벡터 사이의 각도제2 코사인 법칙을 통해 각도도 구할 수 있는데, 각도는 오직 L2 Norm을 통해서만 구할 수 있다. 수식은 다음과 같다.$cosθ=\\frac{|x|_2^2+|y|_2^2−|x−y|_2^2}{2|x|2|y|2}$ 위 수식으로부터 분자를 쉽게 계산하는 방법은 내적이다. 이를 이용하면 다음과 같이 정리할 수 있다. $cosθ=\\frac{2\\langle x,y\\rangle}{2|x|_2|y|_2}$ $\\langle x,y\\rangle$는 각 Vector의 내적의 표현으로 $∑^d_{i=1}x^iy^i$와 동일하다.즉, 코사인 법칙의 분자를 쉽게 구할 수 있는 방법이 바로 벡터의 내적이다.내적은 np.inner함수로 구현할 수 있으며, 이를 코드로 옮기면 다음과 같다. 1234def angle(x, y) : v = np.inner(x, y) / (l2_norm(x) * l2_norm(y)) theta = np.arccos(v) return theta 벡터의 내적(Inner Product)같은 차원을 지닌 벡터에서 서로 대응하는 성분끼리 곱한 다음 이를 모두 더한 값이다. 그래서 벡터의 내적의 결과는 스칼라이다. 정사영(orthogonal projection)된 Vector의 길이와도 관련이 있는데, 벡터 $\\mathbf{x}$를 $\\mathbf{y}$에 정사영된 $Proj(\\mathbf{x})$는 코사인 법칙에 의해 $||\\mathbf{x}||\\cos\\theta$와 동일하게 된다.$Proj(\\mathbf{x})$를 $||\\mathbf{y}||$만큼 조정한 값을 의미한다. 이를 통해 유사도를 측정하는데 사용할 수도 있다. 코사인 유사도벡터의 내적을 사용한 코사인 유사도를 통해 두 벡터의 유사도를 구할 수 있다. $\\cos{(a, b)} = \\frac{\\langle a, b\\rangle} {|a| |b|}$ 코사인 유사도는 항상 -1 이상 1 이하의 값을 지닌다. 두 벡터의 코사인 유사도가 높다는 건 두 벡터의 서로 유사하다는 의미이다. NLP에서의 코사인 유사도텍스트 분석 시 벡터 기반의 단어 또는 문장 간의 관계성을 파악하는 데 활용할 수 있다.","link":"/2022/02/06/20220206-AI-Math-Vector/"}],"tags":[],"categories":[]}